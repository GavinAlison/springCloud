# hystrix 是什么


## hystrix的原理是什么

## hystrix的配置，服务隔离机制

## hystrix的服务降级机制

### 常见场景
	1.服务器宕机，网络不可达
	2.异常流量，重试加大流量
	3.缓存穿透，一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。
		大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用。
	4.程序bug， 如程序逻辑导致内存泄漏，JVM长时间FullGC等。
	5.同步等待，服务间采用同步调用模式，同步等待造成的资源耗尽

### 方法	
---
```
1.多机房容灾、异地多活
2.服务自动扩容、流量控制（限流、关闭重试）
3.缓存预加载、缓存异步加载
4.修改程序bug、及时释放资源
5.资源隔离、MQ解耦，不可用服务调用快速失败
	资源隔离： 线程池，信号量
	不可用服务调用快速失败一般通过熔断模式结合超时机制实现
```

### hystrix作用
限流、降级、容错



### hystrix 执行过程
	服务调用会走hystrix,根据配置信息判断，是否是执行降级逻辑、执行正常逻辑、执行熔断、执行熔断半开。
	然后在走限流器，信号量或者线程池，限制进入熔断器中的并发数。
	
### Hystrix系列之信号量、线程池

#### 信号量
```
配置：execution.isolation.strategy = ExecutionIsolationStrategy.SEMAPHORE
      execution.isolation.semaphore.maxConcurrentRequests
场景：接收请求和执行下游依赖在同一个线程内完成，不存在线程上下文切换所带来的性能开销
实现：一个简单的计数器，当请求进入熔断器时，执行tryAcquire(),计数器加1，结果大于阈值的话，就返回false，发生信号量拒绝事件，执行降级逻辑。
    当请求离开熔断器时，执行release()，计数器减1。
```
	
#### 线程池模式

```
在该模式下，用户请求会被提交到各自的线程池中执行，把执行每个下游服务的线程分离，
从而达到资源隔离的作用。当线程池来不及处理并且请求队列塞满时，新进来的请求将快速失败，
可以避免依赖问题扩散。

在信号量模式提到的问题，对所依赖的多个下游服务，通过线程池的异步执行，可以有效的提高接口性能。

优势

减少所依赖服务发生故障时的影响面，比如ServiceA服务发生异常，导致请求大量超时，对应的线程池被打满，这时并不影响ServiceB、ServiceC的调用。
如果接口性能有变动，可以方便的动态调整线程池的参数或者是超时时间，前提是Hystrix参数实现了动态调整。
缺点

请求在线程池中执行，肯定会带来任务调度、排队和上下文切换带来的开销。
因为涉及到跨线程，那么就存在ThreadLocal数据的传递问题，比如在主线程初始化的ThreadLocal变量，在线程池线程中无法获取



```

## 注意

因为Hystrix默认使用了线程池模式，所以对于每个Command，在初始化的时候，
会创建一个对应的线程池，如果项目中需要进行降级的接口非常多，比如有上百个的话，
不太了解Hystrix内部机制的同学，按照默认配置直接使用，可能就会造成线程资源的大量浪费。

