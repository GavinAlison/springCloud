1. 位图法
分治法
位图法
32

2,147,483,647 ~ 256MB ~ 2G
8
1B=8bit
1KB=1024B
1MB=1024KB


为什么Java中的BitSet使用long数组做内部存储，而不使用int数组或者byte数组？

JDK选择long数组作为BitSet的内部存储结构是出于性能的考虑，因为BitSet提供and和or这种操作，
需要对两个BitSet中的所有bit位做and或者or，实现的时候需要遍历所有的数组元素。
使用long能够使得循环的次数降到最低，所以Java选择使用long数组作为BitSet的内部存储结构。
从数据在栈上的存储来说，使用long和byte基本是没有什么差别的，除了编译器强制地址对齐的时候，
使用byte最多会浪费7个字节(强制按照8的倍数做地址对其)，另外从内存读数组元素的时候，也是没有什么区别的，
因为汇编指令有对不同长度数据的mov指令。所以说，JDK选择使用long数组作为BitSet的内部存储结构的根本原因
就是在and和or的时候减少循环次数，提高性能。


面试知识点：
bitset考吗？
kafka的知识点，kafka的问题，kafka stream 是什么回事，kafka connect 是做什么用的

redis 持久化策略   如何保证数据一致性   数据如何持久化    这个问题妙啊   

对象栈上分配

主要查看对象是在哪儿， 两种
1. 类的成员变量，静态变量-- 堆分配对象
2. 方法的局部变量		-- 逃逸分析之后，栈分配对象

方法的局部变量的分配流程

1.1 对象分配的时候，会分析进行逃逸分析，如果对象不会被别的线程用，就直接栈上分配
节省内存, 避免垃圾回收

它不是static，分配内存的时候，优先尝试栈上分配吧

这个对象会直接分配在方法栈上,随着方法执行完出栈

方法中的局部变量创建的对象，如果这个对象

逃逸分析发生的情况： 
1. 方法逃逸，这个对象通过参数传递出去
2. 线程逃逸，这个对象被其他线程访问到

如果不存在上面两种情况，就会对该对象就行如下优化，锁消除、标量替换和栈上分配。
同步消除： 消除的是对象上的同步锁标识
标量替换： 对象的完整结构是对象头和整个对象的内存布局，一般对象分配是指对象的完整结构，逃逸分析之后会进行对象的拆分分配，
把对象里的Java字段给逐个逐个当作独立的局部变量，例如说把替换后的标量分配到寄存器。

栈上分配： 一般是在堆上分配对象。

java -cp . -Xmx3G -Xmn2G -server -XX:-DoEscapeAnalysis JVM
jps
jmap -histo [pid]
关闭逃逸分析之后，User对象一个不少的都在堆上进行分配。

java -cp . -Xmx3G -Xmn2G -server JVM
开启逃逸分析之后，只有41w左右的User对象在Java堆上分配，其余的对象已经通过标量替换优化了。

java -cp . -Xmx3G -Xmn2G -server -XX:-TieredCompilation
关闭了分层编译之后，在Java堆上分配的User对象降低到1w多个，分层编译对逃逸分析还是有影响的。

编译阈值
通常这个值由-XX:CompileThreshold参数进行设置：
1、使用client编译器时，默认为1500；
2、使用server编译器时，默认为10000；
意味着如果方法调用次数或循环次数达到这个阈值就会触发标准编译，更改CompileThreshold标志的值，将使编译器提早（或延迟）编译。


foo()方法里创建了一个Point对象，并且只有一个局部变量p引用着这个对象。该引用没有被当作参数传给别的方法、没有被当作返回值、也没有被赋值到别的对象的字段/静态字段上，所以没有逃逸。


1.2 尝试在TLAB上分配
指针碰撞和空闲列表
开线程空间为了避免对象分配时的并发问题

1.3 查看配置参数，是否直接在老年代分配，内存大小是否大于多少，分配在老年代

1.4 然后伊甸区，s0，s1

1.5 方法的执行，对象的流转，根据垃圾回收算法进行对象的转移， 从s0-s1, s1-s0, 每次转移，年龄标识+1， 默认大于15，就转移到老年代


## JVM 能否找到一定不会“流出”某个代码块的对象，并且确定地析构它，甚至把它直接“镶嵌”在栈上？



## spring aop是在什么时机生成的代理对象

容器创建的  启动的时候， doGetBean()

